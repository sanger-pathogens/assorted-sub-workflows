#!/usr/bin/env python3

import argparse
import csv
import logging
from pathlib import Path
from typing import TextIO
from collections import OrderedDict

def get_chrom_id_and_size(ref_index: Path) -> dict[str, int]:
    """
    Extracts chromosome IDs and their corresponding sizes from a reference index file.

    Parameters:
    ref_index (Path): Path to the reference index file generated by samtools (or similar).

    Returns:
    dict[str, int]: A dictionary containing chromosome IDs as keys and their corresponding sizes as values.

    Example:
    If the reference index file contains:
    ```
    chr1 248956422
    chr2 242193529
    ```
    The function will return:
    ```
    {'chr1': 248956422, 'chr2': 242193529}
    """
    chrom_id_size = OrderedDict()
    with open(ref_index, "r") as f:
        for line in f:
            seq_id, size, _ = line.split(maxsplit=2)
            chrom_id_size[seq_id] = int(size)
    return chrom_id_size


def initialise_seq(chrom_size: int, default_seq_character) -> list[str]:
    """
    Initializes a list representing a sequence with default characters.

    Parameters:
    chrom_size (int): The size of the chromosome sequence.

    Example:
    Tasked with a genome size of 2_000_000 and a default character of N
    this function will return a list of N 2_000_000 long
    """
    return [default_seq_character] * chrom_size


def parse_lines(fh: TextIO):
    for line in fh:
        if not line.startswith("##"):
            header = line.lstrip("#").split()
            break
    return csv.DictReader(fh, delimiter="\t", fieldnames=header)


def parse_position(pos: str):
    try:
        pos = int(pos)  # reference nucleotide position converted to int
    except ValueError:
        logging.warning(
            f"Expected integer value for nucleotide position but got: '{pos}'"
        )
        return None
    else:
        return pos


def parse_quality(qual: str):
    try:
        qual = float(qual)
    except ValueError:
        if qual == ".":
            return None
        else:
            raise
    else:
        return qual


def is_acceptable_quality(qual: float, pos: int, threshold: int=10, alt_quality: dict=None):
    if alt_quality is None:
         alt_quality = {}
    if qual is None:
        return False
    if qual > threshold or (pos in alt_quality and qual > alt_quality[pos]):
        return True
    return False


def get_nt_to_add(ref: str, alt: str, default_seq_character):
    if len(alt) > 1:
        # if mutiple bases called at a position
        return default_seq_character
    if alt == ".":
        # if the mapped strain is the same as the query, then it is reported as a '.'
        return ref
    # for SNPs
    return alt


def get_seq(
    vcf: Path, ref_index: Path, default_seq_character, qual_threshold: float=10
):
    chrom_id_size = get_chrom_id_and_size(ref_index)
    seq = {}
    for chrom_id, chrom_size in chrom_id_size.items():
        seq[chrom_id] = initialise_seq(chrom_size, default_seq_character)
    
    with open(vcf, "r", newline="") as f:
        parsed_lines = parse_lines(f)
        for line in parsed_lines:
            seq_id = line["CHROM"]
            ref = line["REF"]  # reference base
            alt = line["ALT"]  # alternative base
            pos = parse_position(line["POS"])
            qual = parse_quality(line["QUAL"])
            if seq_id in seq:
                if qual is None:
                    logging.warning(
                        f"The following line had an unexpected quality value: {line}"
                    )
                if is_acceptable_quality(
                    qual, pos, qual_threshold
                ):
                    seq[seq_id][pos - 1] = get_nt_to_add(ref, alt, default_seq_character)
    
    for chrom_id, chrom_seq in seq.items():
        assert len(chrom_seq) == chrom_id_size[chrom_id]
        seq[chrom_id] = "".join(chrom_seq)
    
    return seq


def write_seq(seq: dict, seq_id: str, output_fasta: str="out.fa") -> None:
    with open(output_fasta, "w") as f:
        for chrom_id, sequence in seq.items():
            seq_header = f">{seq_id}_{chrom_id}"
            f.write(f"{seq_header}\n{sequence}\n")


def parse_args():
    parser = argparse.ArgumentParser(
        description="Script to align map reads back to reference"
    )
    parser.add_argument(
        "--sample",
        "-s",
        help="Sample ID of sample whose sequence will be aligned to the reference",
    )
    parser.add_argument(
        "--default_seq_char",
        "-sc",
        default="N",
        help="Default character for ambigigious bases",
    )
    parser.add_argument(
        "--vcf", "-v", help="VCF (generated by `bcftools call`) for the sample"
    )
    parser.add_argument(
        "--ref-index",
        "-i",
        help="Reference index (.fai) for the strain to which the sample will be mapped",
    )
    parser.add_argument(
        "--output",
        "-o",
        help="Output filename for aligned reads (fasta format)",
        default="out.fa",
    )
    return parser.parse_args()


if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )

    args = parse_args()

    seq = get_seq(args.vcf, args.ref_index, args.default_seq_char)
    write_seq(seq, args.sample, args.output)
